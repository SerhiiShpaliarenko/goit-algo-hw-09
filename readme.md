Порівняння ефективності та висновки

1. Оцінка складності (Big O)
#Жадібний алгоритм (find_coins_greedy):
Часова складність: $O(N)$, де $N$ — кількість номіналів монет. 
Оскільки ми просто проходимо по списку монет один раз і виконуємо прості математичні операції (ділення та остача), час виконання майже миттєвий і не залежить від величини суми (amount).
Просторова складність: $O(1)$ (зберігаємо лише результат).
#Динамічне програмування (find_min_coins):
Часова складність:
$O(A \cdot N)$, де $A$ — це сума (amount), а $N$ — кількість номіналів монет.
Нам потрібно заповнити масив розміром $A$, і для кожної комірки ми перебираємо всі $N$ монет.
Просторова складність: $O(A)$ — нам потрібно зберігати масив розміром amount + 1 для запам'ятовування проміжних результатів.

2. Порівняння на практиці (великі суми)
#Для малих сум (наприклад, 113): Різниця непомітна. Обидва алгоритми працюють миттєво.
#Для великих сум (наприклад, 100 000 і більше):
Жадібний алгоритм продовжує працювати миттєво ($< 0.00001$ с). Йому байдуже, чи сума 100, чи 1 мільярд — він просто ділить числа.
Динамічне програмування починає суттєво сповільнюватися. 
Для суми 100 000 цикл має виконати сотні тисяч ітерацій. 
Якщо сума буде 10 000 000, алгоритм DP може зависнути на кілька секунд або викинути помилку переповнення пам'яті (MemoryError), оскільки намагатиметься створити масив на 10 млн елементів.

3. Чому результати однакові?
Для заданого набору монет [50, 25, 10, 5, 2, 1] жадібний підхід гарантовано дає оптимальний результат (мінімальну кількість монет). 
Такі набори монет називаються канонічними.
#Якби набір був нестандартним, наприклад [9, 6, 1], а сума 12:
Жадібний взяв би 9 + 1 + 1 + 1 (4 монети).
DP знайшов би 6 + 6 (2 монети).

Висновки:
1. Жадібний алгоритм є значно ефективнішим за часом і пам'яттю для великих сум. 
Його варто використовувати у реальних касових апаратах для стандартних валютних систем.
2. Динамічне програмування є універсальним методом, який гарантує правильний результат для будь-якого набору монет, але він занадто "важкий" (ресурсомісткий) для простої задачі видачі решти з великими сумами.
3. Найкращий вибір: Для цієї конкретної задачі — жадібний алгоритм є абсолютним переможцем.
